package org.example.trendyolfinalproject.service.impl;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.example.trendyolfinalproject.client.CardClient;
import org.example.trendyolfinalproject.client.TransactionClient;
import org.example.trendyolfinalproject.dao.repository.*;
import org.example.trendyolfinalproject.exception.customExceptions.NotFoundException;
import org.example.trendyolfinalproject.mapper.OrderItemMapper;
import org.example.trendyolfinalproject.mapper.OrderMapper;
import org.example.trendyolfinalproject.model.enums.NotificationType;
import org.example.trendyolfinalproject.model.enums.Status;
import org.example.trendyolfinalproject.model.request.TransactionRequest;
import org.example.trendyolfinalproject.model.response.ApiResponse;
import org.example.trendyolfinalproject.service.*;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.time.LocalDateTime;

@Service
@RequiredArgsConstructor
@Slf4j
public class ReturnRequestImpl implements ReturnRequestService {


    private final OrderRepository orderRepository;
    private final OrderItemRepository orderItemRepository;
    private final OrderMapper orderMapper;
    private final OrderItemMapper orderItemMapper;
    private final UserRepository userRepository;
    private final AdressRepository adressRepository;
    private final PaymentMethodRepository paymentMethodRepository;
    private final BasketRepository basketRepository;
    private final BasketElementRepository basketElementRepository;
    private final PaymentTransactionRepository paymentTransactionRepository;
    private final PaymentTransactionService paymentTransactionService;
    private final ShipmentService shipmentService;
    private final ProductVariantRepository productVariantRepository;
    private final ProductRepository productRepository;
    private final NotificationService notificationService;
    private final EmailService emailService;
    private final AuditLogService auditLogService;
    private final SellerPaymentLogRepository sellerPaymentLogRepository;
    private final SellerRepository sellerRepository;
    private final ReturnRequestRepository returnRequestRepository;
    private final FileStorageService fileStorageService;
    private final TransactionClient transactionClient;
    private final CardClient cardClient;


    @Transactional
    @Override
    public ApiResponse<String> approveReturnRequest(Long returnRequestId) {
        log.info("Actionlog.approveReturnRequest.start : returnRequestId={}", returnRequestId);
        var userId = getCurrentUserId();
        var user = userRepository.findById(userId).orElseThrow(() -> new NotFoundException("User not found with id: " + userId));
        var returnRequest = returnRequestRepository.findById(returnRequestId)
                .orElseThrow(() -> new NotFoundException("ReturnRequest not found with id: " + returnRequestId));

        returnRequest.setApproved(true);
        returnRequestRepository.save(returnRequest);

        var orderItemPrice = returnRequest.getOrderItem().getUnitPrice().multiply(returnRequest.getOrderItem().getQuantity());
        var seller = returnRequest.getOrderItem().getProductId().getSeller().getUser().getId();

        var userPayment = paymentMethodRepository.findByUserId_IdAndIsDefault(returnRequest.getUser().getId(), true).orElseThrow(() -> new NotFoundException("Payment method not found"));
        var adminPayment = paymentMethodRepository.findByUserId_IdAndIsDefault(userId, true).orElseThrow(() -> new NotFoundException("Payment method not found"));
        var sellerPayment = paymentMethodRepository.findByUserId_IdAndIsDefault(seller, true).orElseThrow(() -> new NotFoundException("Payment method not found"));


        BigDecimal adminAmount = orderItemPrice.multiply(BigDecimal.valueOf(0.05));
        BigDecimal sellerAmount = orderItemPrice.multiply(BigDecimal.valueOf(0.95));

        if (adminPayment.getBalance().compareTo(adminAmount) < 0
                || sellerPayment.getBalance().compareTo(sellerAmount) < 0) {

            transactionClient.createTransaction(TransactionRequest.builder()
                    .amount(adminAmount)
                    .receiver(userPayment.getCardNumber())
                    .sender(adminPayment.getCardNumber())
                    .status(Status.FAILED)
                    .transactionDate(LocalDateTime.now())
                    .transactionId(generateTransactionId())
                    .currency(userPayment.getCurrency())
                    .providerResponse("Payment of Refund is failed received from admin orderItem: " + returnRequest.getOrderItem().getProductId().getName())
                    .build());


            transactionClient.createTransaction(TransactionRequest.builder()
                    .amount(sellerAmount)
                    .receiver(userPayment.getCardNumber())
                    .sender(sellerPayment.getCardNumber())
                    .status(Status.FAILED)
                    .transactionDate(LocalDateTime.now())
                    .transactionId(generateTransactionId())
                    .currency(userPayment.getCurrency())
                    .providerResponse("Payment of Refund is failed received from seller orderItem: " + returnRequest.getOrderItem().getProductId().getName())
                    .build());

            throw new RuntimeException("Trendyols balance is not enough");
        }

        userPayment.setBalance(userPayment.getBalance().add(orderItemPrice));
        adminPayment.setBalance(adminPayment.getBalance().subtract(adminAmount));
        sellerPayment.setBalance(sellerPayment.getBalance().subtract(sellerAmount));


        paymentMethodRepository.save(userPayment);
        paymentMethodRepository.save(adminPayment);
        paymentMethodRepository.save(sellerPayment);

        cardClient.transfer(adminPayment.getCardNumber(), userPayment.getCardNumber(), adminAmount);
        cardClient.transfer(sellerPayment.getCardNumber(), userPayment.getCardNumber(), sellerAmount);

        transactionClient.createTransaction(TransactionRequest.builder()
                .amount(adminAmount)
                .receiver(userPayment.getCardNumber())
                .sender(adminPayment.getCardNumber())
                .status(Status.SUCCESS)
                .transactionDate(LocalDateTime.now())
                .transactionId(generateTransactionId())
                .currency(userPayment.getCurrency())
                .providerResponse("Payment of Refund is successfully received from admin orderItem: " + returnRequest.getOrderItem().getProductId().getName())
                .build());

        transactionClient.createTransaction(TransactionRequest.builder()
                .amount(sellerAmount)
                .receiver(userPayment.getCardNumber())
                .sender(sellerPayment.getCardNumber())
                .status(Status.SUCCESS)
                .transactionDate(LocalDateTime.now())
                .transactionId(generateTransactionId())
                .currency(userPayment.getCurrency())
                .providerResponse("Payment of Refund is successfully received from seller orderItem: " + returnRequest.getOrderItem().getProductId().getName())
                .build());


        auditLogService.createAuditLog(user, "APPROVE RETURN REQUEST", "Return request approved successfully. Return request id: " + returnRequestId);
        notificationService.sendNotification(returnRequest.getUser(), "Your return request has been approved.", NotificationType.RETURN_REQUEST_APPROVED, returnRequestId);
        log.info("Actionlog.approveReturnRequest.end : returnRequestId={}", returnRequestId);
        return ApiResponse.<String>builder()
                .status(200)
                .message("Return request approved successfully.")
                .data("Return request approved successfully.")
                .build();
    }
}
